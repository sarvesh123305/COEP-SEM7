#include <iostream>
#include <string>

using namespace std;

class OneTimePad {
private:
    string plaintext;
    string ciphertext;
    string key;

public:
    OneTimePad(const string& pt, const string& ct)
        : plaintext(pt), ciphertext(ct), key("") {}

    void recoverKey() {
        if (plaintext.length() != ciphertext.length()) {
            cerr << "Error: Plaintext and ciphertext lengths do not match!" << endl;
            return;
        }

        key.resize(plaintext.length());

        for (size_t i = 0; i < plaintext.length(); ++i) {
            key[i] = plaintext[i] ^ ciphertext[i];
        }
    }

    void displayKey() const {
        cout << "Recovered Key: ";
        for (char c : key) {
            cout << hex << static_cast<int>(c) << " ";
        }
        cout << endl;
    }

    string decryptWithRecoveredKey(const string& ct) const {
        if (key.empty()) {
            cerr << "Error: Key has not been recovered yet!" << endl;
            return "";
        }

        if (ct.length() != key.length()) {
            cerr << "Error: Ciphertext and key lengths do not match!" << endl;
            return "";
        }

        string decryptedText(ct.length(), '\0');

        for (size_t i = 0; i < ct.length(); ++i) {
            decryptedText[i] = ct[i] ^ key[i];
        }

        return decryptedText;
    }
};

int main() {

    string plaintext = "HELLO";
    string ciphertext = "\x1F\x1B\x1A\x07\x18";  // Example ciphertext generated by XOR

    OneTimePad otp(plaintext, ciphertext);

    otp.recoverKey();

    otp.displayKey();

    string decryptedText = otp.decryptWithRecoveredKey(ciphertext);
    cout << "Decrypted Text: " << decryptedText << endl;

    return 0;
}

